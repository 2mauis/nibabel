=================================
 Images, headers and code design
=================================

In which we set out how we are thinking of medical image formats and
their commonalities.

Headers
=======

Headers contain two types of information:

#. *howto* data: stuff to tell you how to read the image array data from
   file. This must include the shape of the image array and the numeric
   representation (float32, int16), as well as implicit or explicit
   position of the data relative to the beginning of the data file
   (offset). It can be complicated; ECAT - for example - can contain
   more than one frame, and the datatype can be different for each
   frame.
#. *whatis* data: metadata about the meaning of the image array on file.
   We are interested in the relationship of the voxel positions in the
   data array to space in the real world.  In practice (SPM Analyze,
   NIfTI, MINC) this can always be represented as an affine relating
   voxel coordinates to real world coordinates.  We may also be
   interested in what the 'real world' is.  Neither MINC (1.x) nor
   Analyze stores this, but NIfTI can.

Howto data
----------

In order to get data out of files, any image reader will need either -
the header itself, or selected fields from the header.

Different images can make use of different parts of the header, because
the images will work with only a specified set of headers - as dictated
by the image itself.

* in-file data numeric type - ``io_dtype``.  This has no necessary
  relation to the dtype of the data in memory, because scaling factors
  may be applied.  For reading, we may not need this as part of the
  public interface, we can just use it internally to cast the read
  memory to an array.  Setting this attribute will change the output
  dtype on writing.  ECAT file format can have different dtypes per
  frame; for reading, we just cast up to a dtype that can hold all the
  frame dtypes; for writing, we may just write as one type, or disallow
  writing altogether.
* array shape - ``shape``. This may be read (see below :ref:`Lightweight
  Image`).  Maybe it does not make sense to write this directly, but
  write it from the routine that writes the data (which has a shape).
* byte offset - ``offset`` at which data starts.  This is not relevant
  for the way we currently read MINC files for example - and may not be
  relevant for ECAT files, in the sense that it may be the offset to
  only one of the frames in the image, and the frames are of different
  length.


Images
======

We think of an image as being the association of:

#. A data array, of at least three dimensions, where the first three
   dimensions of the array are spatial.
#. A transformation mapping the spatial array (voxel) coordinates to some real
   continuous space (real-world transform).
#. A definition of what this space *is* ('scanner', 'mni', etc).

.. note::

   Why are the first three dimensions spatial?  

   For simplicity, we want the transformation (above) to be spatial.
   Because the images are always at least 3D, and the transform is
   spatial, this means that the tranformation is always exactly 3D.  We
   have to know which of the N image dimensions are spatial. For
   example, if we have a 4D (space and time) image, we need to know
   which of the 4 dimensions are spatial.  We could ask the image to
   tell us, but the simplest thing is to assert which dimensions are
   spatial by convention, and obey that convention with our image
   readers.

   Right, but why the *first* three dimensions?

   Of course, it could be the last three dimensions.  We chose to use
   the first three dimensions because that is the convention encoded in
   the NIfTI standard, at least implicitly, and it will be familiar to
   users of packages like SPM.  Users of Numpy will have a slight
   preference for the first dimension of an array being the slowest
   changing on disk, and the instinct that time, rather than space, will
   usually be the slowest changing dimension on disk, but we didn't want
   to break the NItTI and SPM conventions, on the basis of this
   instinct, because the instinct is difficult to explain to people who
   don't have it.

So, our image likely has::

   img.data
   img.affine
   img.output_space

Lightweight and heavyweight images
==================================

Heavyweight image
-----------------

We've immediately got something obvious for our image class::

   img = Image(data, affine, output_space)

If we're constructing an image in memory, all is simple::

   data = img.data
   affine = img.affine

just does attribute access.

The image contains the full data array (or a reference to it).  This can
be very large, and the image can contain the only reference to the data,
so this is the *heavyweight* image version.

For this version, getting the shape of the image could be::

   shape = img.data.shape

or::

   shape = img.shape

where ``img.shape`` will just return ``img.data.shape``

Lightweight image
-----------------

However, when we load an image from disk, we often want to - for
example - look at the affine, or the shape, before either deleting the
image object in memory, or passing the image filename to some other
routine - such as FSL.  In this case we will want to delay a full load of the data because we may not need it, and it is very expensive::

   img = load('some_filename.nii')

Where ``img`` will have some delayed reference scheme for reading the
data iff we need it.

This is the *lightweight* image version, and only arises when there is
some version of the image on disk.

For the lightweight image, we may want to look at ``img.shape`` without
loading all the data (it will be known, from the header).  

Empty image
-----------

This is a reminder of Souheil Inati's use-case - the iterative write.
Perhaps something like::

    empty_image = Nifti1Image.empty_image(shape=(64,64,30,150), affine=np.eye(4))
    empty_image.set_filespec('some_image.nii.gz')
    empty_image.write_header()
    for i in range(150):
        slicer = (slice(None),)*3 + (i,)
        data = np.random.normal(size=(64,64,30))
        empty_image.write_image_slice(data, slicer)

 

